zabbix_export:
  version: '6.4'
  media_types:
    - 
      name: Telegram
      type: WEBHOOK
      parameters:
        - name: event_tags
          value: '{EVENT.TAGSJSON}'
        - name: event_update_status
          value: '{EVENT.UPDATE.STATUS}'
        - name: event_value
          value: '{EVENT.VALUE}'
        - name: Message
          value: '{ALERT.MESSAGE}'
        - name: ParseMode
          value: markdown
        - name: Subject
          value: '{ALERT.SUBJECT}'
        - name: To
          value: 'channel'
        - name: Token
          value: 'Put token here'
      script: |
        var 
            result = {tags: {}},
            Telegram = {
            token: null,
            to: null,
            message: null,
            proxy: null,
            parse_mode: null,
        
            escapeMarkup: function (str, mode) {
                switch (mode) {
                    case 'markdown':
                        return str.replace(/([_*\[`])/g, '\\$&');
        
                    case 'markdownv2':
                        return str.replace(/([_*\[\]()~`>#+\-=|{}.!])/g, '\\$&');
        
                    default:
                        return str;
                }
            },
        
            newMessage: function () {
                var params = {
                    chat_id: Telegram.to,
                    text: Telegram.message,
                    disable_web_page_preview: true,
                    disable_notification: false
                },
                data,
                response,
                request = new HttpRequest(),
                url = 'https://api.telegram.org/bot' + Telegram.token + '/sendMessage';
        
                if (Telegram.parse_mode !== null) {
                    params['parse_mode'] = Telegram.parse_mode;
                }
        
                if (Telegram.proxy) {
                    request.setProxy(Telegram.proxy);
                }
        
                request.addHeader('Content-Type: application/json');
                data = JSON.stringify(params);
        
                response = request.post(url, data);
        
                try {
                    response = JSON.parse(response);
                }
                catch (error) {
                    response = null;
                }
        
                result.tags = {
                    ['__message_ts_']: response.result.message_id,
                };
        
                if (request.getStatus() !== 200 || typeof response.ok !== 'boolean' || response.ok !== true) {
                    if (typeof response.description === 'string') {
                        throw response.description;
                    }
                    else {
                        throw 'Unknown error. Check debug log for more information.';
                    }
                }
            },
            deleteMessage: function () {
                var params = {
                    chat_id: Telegram.to,
                    message_id: Telegram.message_id,
                },
                data,
                response,
                request = new HttpRequest(),
                url = 'https://api.telegram.org/bot' + Telegram.token + '/deleteMessage';
        
                if (Telegram.parse_mode !== null) {
                    params['parse_mode'] = Telegram.parse_mode;
                }
        
                if (Telegram.proxy) {
                    request.setProxy(Telegram.proxy);
                }
        
                request.addHeader('Content-Type: application/json');
                data = JSON.stringify(params);
        
                response = request.post(url, data);
        
                try {
                    response = JSON.parse(response);
                }
                catch (error) {
                    response = null;
                }
        
                if (request.getStatus() !== 200 || typeof response.ok !== 'boolean' || response.ok !== true) {
                    if (typeof response.description === 'string') {
                        throw response.description;
                    }
                    else {
                        throw 'Unknown error. Check debug log for more information.';
                    }
                }
            },
        
            editMessage: function () {
                var params = {
                    chat_id: Telegram.to,
                    text: Telegram.message,
                    disable_web_page_preview: true,
                    disable_notification: false,
                    message_id: Telegram.message_id,
                },
                data,
                response,
                request = new HttpRequest(),
                url = 'https://api.telegram.org/bot' + Telegram.token + '/editMessageText';
        
                if (Telegram.parse_mode !== null) {
                    params['parse_mode'] = Telegram.parse_mode;
                }
        
                if (Telegram.proxy) {
                    request.setProxy(Telegram.proxy);
                }
        
                request.addHeader('Content-Type: application/json');
                data = JSON.stringify(params);
        
                response = request.post(url, data);
        
                try {
                    response = JSON.parse(response);
                }
                catch (error) {
                    response = null;
                }
        
                if (request.getStatus() !== 200 || typeof response.ok !== 'boolean' || response.ok !== true) {
                    if (typeof response.description === 'string') {
                        throw response.description;
                    }
                    else {
                        throw 'Unknown error. Check debug log for more information.';
                    }
                }
            },
        
        
        };
        
        try {
            var params = JSON.parse(value);
        
            if (typeof params.Token === 'undefined') {
                throw 'Incorrect value is given for parameter "Token": parameter is missing';
            }
        
            Zabbix.log(4, 'Resolve message id ' + params.event_tags);
            Zabbix.log(4, 'event_value ' + params.event_value);
            Zabbix.log(4, 'event_update_status ' + params.event_update_status);
        
            Telegram.token = params.Token;
        
            if (params.HTTPProxy) {
                Telegram.proxy = params.HTTPProxy;
            } 
        
            params.ParseMode = params.ParseMode.toLowerCase();
            
            if (['markdown', 'html', 'markdownv2'].indexOf(params.ParseMode) !== -1) {
                Telegram.parse_mode = params.ParseMode;
            }
        
            Telegram.to = params.To;
            Telegram.message = params.Subject + '\n' + params.Message;
        
            if (['markdown', 'markdownv2'].indexOf(params.ParseMode) !== -1) {
                Telegram.message = Telegram.escapeMarkup(Telegram.message, params.ParseMode);
            }
        
            // Problem
            if (params.event_value==1 && params.event_update_status == 0) {   
               Telegram.newMessage();
               res = JSON.stringify(result)
               Zabbix.log(4, '[Telegram Webhook] notification was send: ' + res);
               return res;
              };
        
            // Resolve
            if (params.event_value == 0) {
                var channel_event_tags = JSON.parse(params.event_tags);
         
                if (Array.isArray(channel_event_tags)) {
                    for (i in channel_event_tags) {
                        if (channel_event_tags[i].tag.includes('__message_ts_')) {
                            Telegram.message_id = channel_event_tags[i].value;
                            break;
                        }
                    }
                }
                Zabbix.log(4, 'Resolve message id ' + Telegram.message_id);
                Telegram.editMessage();
                return 'OK';
            };
        
            // return 'OK';
        
        }
        catch (error) {
            Zabbix.log(4, '[Telegram Webhook] notification failed: ' + error);
            throw 'Sending failed: ' + error + '.';
        }
      timeout: 10s
      process_tags: 'YES'
      description: |
        https://git.zabbix.com/projects/ZBX/repos/zabbix/browse/templates/media/telegram
        
        1. Register bot: send "/newbot" to @BotFather and follow instructions
        2. Copy and paste the obtained token into the "Token" field above
        3. If you want to send personal notifications, you need to get chat id of the user you want to send messages to:
            3.1. Send "/getid" to "@myidbot" in Telegram messenger
            3.2. Copy returned chat id and save it in the "Telegram Webhook" media for the user
            3.3. Ask the user to send "/start" to your bot (Telegram bot won't send anything to the user without it)
        4. If you want to send group notifications, you need to get group id of the group you want to send messages to:
            4.1. Add "@myidbot" to your group
            4.2. Send "/getgroupid@myidbot" in your group
            4.3. Copy returned group id save it in the "Telegram Webhook" media for the user you created for  group notifications
            4.4. Send "/start@your_bot_name_here" in your group (Telegram bot won't send anything to the group without it)
      message_templates:
        - event_source: TRIGGERS
          operation_mode: PROBLEM
          subject: 'Problem: {EVENT.NAME}'
          message: |
            **Problem started at {EVENT.TIME} on {EVENT.DATE}**
            Problem name: {EVENT.NAME}
            Host: {HOST.NAME}
            Severity: {EVENT.SEVERITY}
            Operational data: {EVENT.OPDATA}
            Original problem ID: {EVENT.ID}
            {TRIGGER.URL}
        - event_source: TRIGGERS
          operation_mode: RECOVERY
          subject: 'Resolved in {EVENT.DURATION}: {EVENT.NAME}'
          message: |
            Problem has been resolved in {EVENT.DURATION} at {EVENT.RECOVERY.TIME} on {EVENT.RECOVERY.DATE}
            Problem name: {EVENT.NAME}
            Host: {HOST.NAME}
            Severity: {EVENT.SEVERITY}
            Original problem ID: {EVENT.ID}
            {TRIGGER.URL}
        - event_source: TRIGGERS
          operation_mode: UPDATE
          subject: 'Updated problem: {EVENT.NAME}'
          message: |
            {USER.FULLNAME} {EVENT.UPDATE.ACTION} problem at {EVENT.UPDATE.DATE} {EVENT.UPDATE.TIME}.
            {EVENT.UPDATE.MESSAGE}
            
            Current problem status is {EVENT.STATUS}, acknowledged: {EVENT.ACK.STATUS}.
        - event_source: DISCOVERY
          operation_mode: PROBLEM
          subject: 'Discovery: {DISCOVERY.DEVICE.STATUS} {DISCOVERY.DEVICE.IPADDRESS}'
          message: |
            Discovery rule: {DISCOVERY.RULE.NAME}
            
            Device IP: {DISCOVERY.DEVICE.IPADDRESS}
            Device DNS: {DISCOVERY.DEVICE.DNS}
            Device status: {DISCOVERY.DEVICE.STATUS}
            Device uptime: {DISCOVERY.DEVICE.UPTIME}
            
            Device service name: {DISCOVERY.SERVICE.NAME}
            Device service port: {DISCOVERY.SERVICE.PORT}
            Device service status: {DISCOVERY.SERVICE.STATUS}
            Device service uptime: {DISCOVERY.SERVICE.UPTIME}
        - event_source: AUTOREGISTRATION
          operation_mode: PROBLEM
          subject: 'Autoregistration: {HOST.HOST}'
          message: |
            Host name: {HOST.HOST}
            Host IP: {HOST.IP}
            Agent port: {HOST.PORT}
